# ----------------------------------------------------------------------------
# R-code (www.r-project.org/) MASTER FUNCTION to obtain a design matrix for
# the analysis of data from stable roommates or coalition formation games
#
# Copyright (c) 2013 Thilo Klein
#
# This library is distributed under the terms of the GNU Public License (GPL)
# for full details see the file LICENSE
#
# ----------------------------------------------------------------------------

#' @title Design matrix for one-sided matching markets
#'
#' @description Returns a model matrix with characteristics of \emph{all feasible} groups
#' of the same size as the observed groups in the market. 
#' 
#' For example, in the stable roommates problem with \eqn{n=4} students 
#' \eqn{\{1,2,3,4\}}{{1,2,3,4}} sorting into groups of 2, 
#' we have \eqn{{4 \choose 2}=6}{"4 choose 2" = 6} feasible groups: (1,2)(3,4) (1,3)(2,4) 
#' (1,4)(2,3).
#' 
#' In the group formation problem with \eqn{n=6} students 
#' \eqn{\{1,2,3,4,5,6\}}{{1,2,3,4,5,6}} sorting into groups of 3, 
#' we have \eqn{{6 \choose 3}=20}{"6 choose 3" = 20} feasible groups. 
#' For the same students sorting into groups of sizes 2 and 4, 
#' we have \eqn{{6 \choose 2} + {6 \choose 4}=30}{"6 choose 2" + "6 choose 4" = 30} feasible groups.
#' 
#' The input is individual-level 
#' data of all group members from one-sided matching marktes; that is, from group/coalition
#' formation games. 
#'
#' @param x data frame with individual-level characteristics of all group members including
#' market- and group-identifiers.
#' @param m.id character string giving the name of the market identifier variable. Defaults to \code{"m.id"}.
#' @param g.id character string giving the name of the group identifier variable. Defaults to \code{"g.id"}.
#' @param R dependent variable in outcome equation. Defaults to \code{"R"}.
#' @param selection list containing variables and pertaining operators in the selection equation. The format is \code{operation = "variable"}. See the Details and Examples sections.
#' @param outcome list containing variables and pertaining operators in the outcome equation. The format is \code{operation = "variable"}. See the Details and Examples sections.
#' @param roommates logical: if \code{TRUE} data is assumed to come from a roomate game. This means that groups are of size two and the model matrix is prepared for individual-level analysis (peer-effects estimation). If \code{FALSE} (which is the default) data is assumed to come from a group/coalition formation game and the model matrix is prepared for group-level analysis.
#' @param simulation logical: if \code{TRUE} the dependent variables of selection and outcome equations are simulated as follows: (i) model coefficients in both equations \code{alpha=beta=1}; (ii) covariance between error terms \code{delta=0.5}; (iii) error terms \code{eta} and \code{xi} are draws from a standard normal distribution.
#' @param assignment character string giving the assignment procedure to be used if \code{simulation=TRUE}. Either \code{"NTU"} for non-transferable utility (which is the default value), \code{"TU"} for transferable utility or \code{"random"} for random assignment of individuals to groups.
#' @param seed integer setting the state for random number generation if \code{simulation=TRUE}.
#' @param max.combs integer (divisible by two) giving the maximum number of feasible groups to be used for generating group-level characteristics.
#' @export
#' @details 
#' Operators for variable transformations in \code{selection} and \code{outcome} arguments.
#' \describe{
#' \item{\code{add}}{sum over all group members and divide by group size.}
#' \item{\code{int}}{sum over all possible two-way interactions \eqn{x*y} of group members
#' and divide by the number of those, given by \code{choose(n,2)}.}
#' \item{\code{ieq}}{sum over all possible two-way equality assertions \eqn{1[x=y]} and
#' divide by the number of those.}
#' \item{\code{ive}}{sum over all possible two-way interactions of vectors
#' of variables of group members and divide by number of those.}
#' \item{\code{dst}}{sum over all possible two-way distances between players and divide by
#' number of those, where distance is defined as \eqn{e^{-|x-y|}}{exp(-|x-y|)}.}
#' \item{\code{sel}}{for \code{roommates=TRUE} only: variable for individual (for peer effects estimation).}
#' \item{\code{oth}}{for \code{roommates=TRUE} only: variable for other in the group (for peer effects estimation).}
#' }
#' @return
#' \code{design.matrix} returns a list with the following lists, whose elements each represent a matching market.
#' \item{D}{vector that indicates -- for all feasible groups in the market -- whether a group is observed in the data \code{D=1} or not \code{D=0}.}
#' \item{V}{vector of group valuations for all feasible groups in the market.}
#' \item{R}{vector of group outcomes for observed groups in the market only.}
#' \item{W}{data frame of group characteristics for all feasible groups in the market.}
#' \item{X}{data frame of group characteristics for observed groups in the market only.}
#' \item{P}{vector that gives for each group the index of the group comprised of residual individuals in the market (for 2-group markets).}
#' \item{combs}{partitions matrix that gives all feasible partitions of the market into groups of the observed sizes.}
#' \item{eta}{if \code{simulation=TRUE}, the standard normally distributed errors in the selection equation.}
#' \item{xi}{if \code{simulation=TRUE}, the standard normally distributed component of the errors in the selection equation that is independent of \code{eta}.}
#' \item{epsilon}{if \code{simulation=TRUE}, the errors in the outcome equation, given by \code{delta*eta + xi}.}
#' \item{E}{matrix that gives the indices of equilibrium group members for each group in the market. Only differs from the first two rows in \code{combs} if \code{simulation=TRUE}.}
#' @author Thilo Klein 
#' @keywords generate
#' @import partitions lpSolve
#' @examples
#' ###############
#' ## ROOMMATES ##
#' ###############
#' 
#' ## Simulate one-sided matching data for 3 markets (m=3) with 3 groups 
#' ## per market (gpm=3) and 2 individuals per group (ind=2)
#' idata <- simData(m=3, ind=2, gpm=3)
#' 
#' ## Generate the design matrix
#' mdata <- design.matrix(x=idata, 
#'   selection = list(add="pi", ieq="wst"), 
#'   outcome = list(add="pi", ieq="wst"), 
#'   assignment="TU", roommates=TRUE, simulation=TRUE)
#'
#' ################
#' ## COALITIONS ##
#' ################
#' 
#' ## EITHER: Simulate one-sided matching data for 3 markets (m=3) with 2 groups 
#' ## per market (gpm=2) and 2 to 4 individuals per group (ind=2:4)
#' idata <- simData(m=3, ind=2:4, gpm=2)
#' 
#' ## Generate the design matrix
#' mdata <- design.matrix(x=idata, 
#'   selection = list(add="pi", ieq="wst"), 
#'   outcome = list(add="pi", ieq="wst"), 
#'   assignment="NTU", roommates=FALSE, simulation=TRUE)
#'
#' \dontrun{
#' ## OR: Load baac00 data from the Townsend Thai project
#' data(baac00)
#' 
#' ## Generate the design matrix
#' mdata <- design.matrix(x=baac00, 
#'   selection = list(add="pi", int="pi", ieq="wst", ive="occ"), 
#'   outcome = list(add="pi", int="pi", ieq="wst", ive="occ", 
#'     add=c("loan_size","loan_size2","lngroup_agei")),
#'   simulation=FALSE)}
design.matrix <- function(x, m.id="m.id", g.id="g.id", R="R", selection=NULL, outcome=NULL, 
  roommates=FALSE, simulation=FALSE, assignment="NTU", seed=123, max.combs=Inf){  
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) to obtain a design matrix for the analysis
  # of data from the stable roommates or coalition formation game.
  
  # Calls the following functions in the given order:
  # 1. listByMarket
  # 2. speci
  # 3. combmats.coalitions / combmats.roomates
  # 4. indexmat
  # 5. designmatrix (-> wrap -> combmats.interactions)
  # --------------------------------------------------------------------

  ## rename dependent variable, group and market identifiers
  names(x)[names(x) == R]    <- "R"
  names(x)[names(x) == g.id] <- "g.id"
  names(x)[names(x) == m.id] <- "m.id"
  
  ## list data by market id
  x <- listByMarket(x=x, m.id=m.id, g.id=g.id, R=R)
  
  ## create combinatorial matrices
  spec <- speci(x=x, roommates=roommates)
  
  if(roommates==TRUE){
    CMATS <- combmats.roommates(x=spec, double=TRUE)
  } else if(roommates==FALSE){
    CMATS <- combmats.coalitions(x=spec, dodrop=TRUE, max.combs=max.combs) 
  }
  INDEXMAT <- indexmat(spec)
  
  ## create design matrix
  designmatrix(selection=selection, outcome=outcome, x=x, roommates=roommates, 
    simulation=simulation, assignment=assignment, seed=seed, spec=spec, CMATS=CMATS,
    INDEXMAT=INDEXMAT)
}




combmats.coalitions <- function(x=NULL, n1, n2, dodrop=FALSE, max.combs=Inf){
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) for obtaining all possible groups when 
  # partitioning the market into TWO groups of size 'n1' and 'n2'.
  # The resulting matrix has number of rows equal to all possible groups
  # with each each row containing the group members' indices.
  
  # The arguments of the function are either:
  # n1 : integer indicating the number of individuals in group 1
  # n2 : integer indicating the number of individuals in group 2
  #
  # OR:
  # x : vector indicating the number of individuals in group 1 and 2,
  #     or a matrix with two columns indicating the number of individuals 
  #     in group 1 and 2, and number of rows equal to the number of markets
  # 
  # AND:
  # dodrop    : logical, should the two observed groups be dropped?
  # max.combs : integer (divisible by two) giving the maximum number of feasible 
  #             groups to be used for generating group-level characteristics.

  
  # ## Examples:
  #
  # combmats.coalitions(n1=2, n2=2)
  # combmats.coalitions(n1=2, n2=2, dodrop=TRUE)
  # combmats.coalitions(x=c(2,3))
  # combmats.coalitions(x=matrix(1:4, ncol=2, nrow=2, byrow=TRUE))
  # --------------------------------------------------------------------
  
  #library(partitions)
  #set.seed(123)
  
  ## If 'x' not given, obtain it from 'n1' and 'n2'
  if(is.null(x)){
    x <- c(n1,n2)
  }
  
  ## Consistency checks:
  if(is.matrix(x)==FALSE){
    if(length(x)>2){stop("combmats() does only handle two groups per market!")}
    x <- matrix(x, ncol=2)
  } else{
    if(dim(x)[2]>2){stop("combmats() does only handle two groups per market!")}
  }
  
  ## sufficient to obtain partitions for unique elements of 'x'  
  x <- t(sapply(1:dim(x)[1], function(j) sort(x[j,]) ))  # order doesn't matter
  x <- unique(x)  # drop duplicates
  
  lapply(1:dim(x)[1], function(i){

    if( choose(sum(x[i,]), x[i,1]) < max.combs ){ ## if number of feasible groups below limit
      L  <- listParts(x[i,])
      L1 <- t(sapply(1:length(L), function(z) c(L[[z]][2]$`2`,rep(NA,abs(diff(x[i,])))) ))
      L2 <- t(sapply(1:length(L), function(z) L[[z]][1]$`1` ))
      LC <- rbind(L1,L2)
    
      if(dodrop){
        ## prepare variables needed to drop indices of the two observed groups in the market
        numA <- x[i,1]; rangeA <- 1:numA
        numB <- x[i,2]; rangeB <- (numA+1):(numB+numA)      
        ncombs <- dim(LC)[1]
        num    <- c(rep(numA,ncombs/2), rep(numB,ncombs/2))
      
        todrop <- NA; s <- 1  # two write the rows of indices of the 2 observed groups to be dropped
        for(j in 1:ncombs){
          indices <- LC[j,1:num[j]]
          if( (all.equal(indices, rangeA)==TRUE) | (all.equal(indices, rangeB)==TRUE) ){
            todrop[s] <- j
            s <- s+1
          }
        }
        LC <- LC[-todrop,]
      } else{
        LC <- LC
      }
    } else{
      A <- t(sapply(1:max.combs, function(z) sort(sample(1:sum(x[i,]),x[i,1],replace=F))))
      A <- A[apply(A,1,function(z) all.equal(z, 1:x[i,1])!=TRUE),] ## drop equilibrium groups
      dim(unique(A))
      A <- unique(A)[1:(max.combs/2),]
      B <- t(apply(A,1,function(z) sort(c(1:sum(x[i,]))[-z])))
      LC <- rbind(cbind(A,matrix(NA,nrow=max.combs/2,ncol=dim(B)[2]-dim(A)[2])),B)
    }
  })
}




combmats.roommates <- function(x=NULL, double=FALSE){ 
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) for obtaining all possible groups when 
  # partitioning a market into groups of size TWO. The resulting matrix has
  # number of rows equal to all possible groups with each row containing
  # group members' indices.
  
  # The arguments of the function are:
  # x      : integer indicating the number of individuals in the market,
  #          or vector indicating the number of individuals in market
  #          1:length(x).
  # double : logical, does order matter? I.e. should both 1,2 and 2,1 be printed?
  
  # ## Examples:
  #
  # combmats.roommates(x=38)
  # combmats.roommates(x=c(2,3))
  # combmats.roommates(x=c(4,4), double=TRUE)
  # --------------------------------------------------------------------
  
  ## Consistency checks:
  if(is.null(dim(x))==FALSE){stop("'x' must be of dimension NULL!")}
  if(is.numeric(x)==FALSE){stop("'x' must be numeric!")}
  
  x <- unique(x)  # drop duplicates
  l <- list()
  for(i in 1:length(x)){
    s <- NULL
    for(j in 1:(x[i]-1)){
      for(k in (1+j):x[i]){
        s <- rbind(s, c(j,k))
      }
    }
    
    if(double){
      if(x[i]%/%2 - x[i]/2 != 0){stop("market size must be a multiple of 2!")}
      obs <- matrix(1:x[i],ncol=2,byrow=TRUE)  # single equ groups
      obs <- rbind(obs, cbind(obs[,2], obs[,1]))  # double equ groups
      s <- rbind(s, cbind(s[,2], s[,1]))
      s <- s[ -which(apply(s,1,toString) %in% apply(obs, 1, toString)), ]
      s <- rbind( obs, s)
    }
    l[[i]] <- s
  }
  return(l)
}




indexmat <- function(x=NULL){
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) for setting up an index matrix for quick 
  # indexing to the list of combination matrices (combmats.coalitions and
  # combmats.roommates) based on the number and size of groups in a market.
  
  # The arguments of the function are:
  # x : Either: a matrix with columns indicating the number of individuals in
  #             group 1 and 2, and number of rows equal to the number of markets.
  #     Or: a vector of length equal to the number of markets, giving the 
  #         number of players in each market.
  
  # ## Examples:
  #
  # ## index matrices for coalition formation game
  # indexmat(x=matrix(c(1,2,2,1,3,3), ncol=2, nrow=3))
  # indexmat(x=matrix(1:6, ncol=2, nrow=3))
  # 
  # ## index vector for roommates game
  # indexmat(x=c(4,8))
  # indexmat(x=c(8,8))
  # --------------------------------------------------------------------
  
  ## Consistency checks:
  if(is.matrix(x)){
    if(dim(x)[2]!=2){stop("'x' must have 2 columns!")}
    
    ## sufficient to obtain partitions for unique elements of 'x'  
    x <- t(sapply(1:dim(x)[1], function(j) sort(x[j,]) ))  # order doesn't matter
    x <- unique(x)  # drop duplicates  
    
    mat <- matrix(NA, nrow=max(x), ncol=max(x))
    for(i in 1:dim(x)[1]){ 
      mat[x[i,1],x[i,2]] <- i
      mat[x[i,2],x[i,1]] <- i
    }
    return(mat)
  } else{
    x <- unique(x)  # drop duplicates
    mat <- rep(NA,max(x))
    for(i in 1:length(x)){
      mat[x[i]] <- i
    }
    return(mat)
  }
}




listByMarket <- function(x, m.id, g.id, R){
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) for creating a list of markets from 
  # one-sided matching data.
  
  # The arguments of the function are:
  # x    : data frame 
  # m.id : variable name of market identifier
  # g.id : variable name of group identifier
  # R    : dependent variable
  
  # ## Examples:
  #
  # listByMarket(x=data, g.id="g.id", m.id="m.id")
  # --------------------------------------------------------------------
  
  ## Consistency checks:
  if(is.null(g.id) | is.null(m.id)){stop("variables 'g.id' and/or 'm.id' missing!")}
  
  ## data.frame to list
  x <- split(x, x$m.id)
  
  ## add group size (g.size), number of groups (g.numb), and individual identifier (i.id)
  x <- lapply(x, function(i) data.frame(i, g.size=rep(table(i$g.id),table(i$g.id)),
       g.numb=length(unique(i$g.id))))
  
  ## normalise g.id to counts staring from 1,2,...
  x <- lapply(x, function(i) data.frame(g.id=as.numeric(factor(i$g.id)), i.id=1:dim(i)[1], m.id=i$m.id, 
    i[-which(names(i)%in%c("m.id","i.id","g.id"))]) )
  
  ## sort list such that two-group markets are listed first
  l <- unlist(lapply(x, function(i) length(unique(i$g.id))))
  x <- x[order(l,decreasing=TRUE)]
    
  return(x)
}




speci <- function(x, roommates=FALSE){
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) for creating either: a group size matrix with
  # number of rows equal to the number of markets and 2 columns indicating the
  # number of players in group 1 and 2 respectively; or: a vector of length 
  # equal to the number of markets with each element giving the market size.
  
  # The arguments of the function are:
  # x         : data list from listByMarket()
  # roommates : logical, whether the group size matrix for coalition formation
  #             games (FALSE) or the market size vector for roommate games (TRUE)
  #             should be generated.
  
  # ## Examples:
  #
  # speci(x=data)
  # --------------------------------------------------------------------
  
  if(roommates==FALSE){
    spec <- unlist(lapply(1:length(x), function(i){
      if(2 %in% x[[i]]$g.numb){  # only for 2-group markets
        table(x[[i]]$g.id )
      }
    }))
    spec <- matrix(spec, byrow=TRUE, ncol=2)
    spec <- t(sapply(1:dim(spec)[1], function(j) sort(spec[j,]) ))  # order doesn't matter
    return(spec)
  } else {
    spec <- sapply(1:length(x), function(i) dim(x[[i]])[1])
    return(spec)
  }
}




combmats.interactions <- function(x=NULL){ 
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) for obtaining all possible groups when 
  # partitioning a market into groups of size TWO.
  
  # The arguments of the function are:
  # x : integer indicating the indices of selected individuals in the market
  
  # ## Examples:
  #
  # combmats.interactions(x=c(1,3,5))
  # --------------------------------------------------------------------
  
  ## Consistency checks:
  if(is.null(dim(x))==FALSE){stop("'x' must be of dimension NULL!")}
  
  l <- length(x)
  s <- NULL
  for(j in 1:(l-1)){
    for(k in (1+j):l){
      s <- rbind(s, x[c(j,k)])
    }
  }
  return(s)
}




wrap <- function(thisdata, indices, num, denom, j, names.xw){
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) to wrap the below group variable 
  # transformations.
  
  # The arguments of the function are:
  # thisdata : matching data for a particular market
  # indices  : indices of the group members
  # num      : group size (= number of indices)
  # denom    : number of possible ways to draw pairs from the group with size 'num'
  # j        : index running from 1 to number of possible groups in the market
  # names.xw : variable names in outcome (x) and selection (w) equation
  
  # ## Examples:
  # 
  # wrap()
  # --------------------------------------------------------------------
  
  comb <- combmats.interactions(x=indices)  # for pipj terms
  varq <- sapply(1:length(names.xw), function(i) strsplit(names.xw[i],split="@")[[1]])[1,]
  funq <- sapply(1:length(names.xw), function(i) strsplit(names.xw[i],split="@")[[1]])[2,]
  
  l <- 1:length(varq)
  sapply(l, function(a){
    if(funq[a]=="add"){
      sum(thisdata[indices,varq[a]], na.rm=TRUE)/num[j]
    } else if(funq[a]=="int"){
      sum( thisdata[comb[,1],varq[a]] * thisdata[comb[,2],varq[a]] ) / denom[j]
    } else if(funq[a]=="dst"){
      sum( exp( -1 * abs( thisdata[comb[,1],varq[a]] - thisdata[comb[,2],varq[a]] ))) / denom[j]
    } else if(funq[a]=="iln"){
      sum( log(thisdata[comb[,1],varq[a]] * thisdata[comb[,2],varq[a]]) ) / denom[j]
    } else if(funq[a]=="ieq"){
      sum( thisdata[comb[,1],varq[a]] == thisdata[comb[,2],varq[a]] ) / denom[j]
    } else if(funq[a]=="ive"){
      n <- nchar(names(thisdata))
      posis <- which( substr(names(thisdata), 1, n-1) == varq[a])
      sum( diag(as.matrix(thisdata[comb[,1],posis]) %*% t(as.matrix(thisdata[comb[,2],posis]))) ) / denom[j]
    } else if(funq[a]=="iem"){
      n <- nchar(names(thisdata))
      posis <- which( substr(names(thisdata), 1, n-1) == varq[a])
      fu <- function(a,b) apply(cbind(a,b), 1, function(z) z[1:(length(z)/2)] %in% z[(length(z)/2):length(z)])
      sum( fu(a=thisdata[comb[,1],posis], b=thisdata[comb[,2],posis]) ) / denom[j] / 2
    } else if(funq[a]=="sel"){
      thisdata[indices[1],varq[a]]
    } else if(funq[a]=="oth"){
      thisdata[indices[2],varq[a]]
    } else if(funq[a]=="avg"){
      mean(thisdata["<me>",varq[a]])
    } else if(funq[a]=="val"){
      n <- nchar(names(thisdata))
      ##posis = which( substr(names(thisdata), 1, n-1) == varq[a] )
      posis <- which( names(thisdata) %in% paste(varq[a],1:1000,sep="") )
      thisdata[indices[1], posis[indices[2]]]
    } else if(funq[a]=="val2"){
      n <- nchar(names(thisdata))
      posis <- which( names(thisdata) %in% paste(varq[a],1:1000,sep="") )
      thisdata[indices[1], posis[indices[2]]] + thisdata[indices[2], posis[indices[1]]]
    } else(stop("function must be either of 'add', 'int', 'ieq', 'ive' or 'iem'!"))
  })
}




designmatrix <- function(selection, outcome, x, roommates=FALSE, simulation=FALSE, assignment, 
  seed, spec, CMATS, INDEXMAT){ 
  
  # --------------------------------------------------------------------
  # R-code (www.r-project.org) to set up the design matrix for the analysis
  # of matching data.
  
  # The arguments of the function are:
  # selection : list ...
  # outcome   : list ...
  # x         : list from listByMarket
  # roommates : logical: if TRUE data is assumed to come from a roomate game.
  # simulation: logical: if TRUE the dependent variables of selection and outcome equations are simulated
  # assignment: character string giving the assignment procedure to be used if simulation=TRUE.
  # seed      : integer setting the state for random number generation if simulation=TRUE.
  # spec      : object from function speci(). Either: a group size matrix with number of rows
  #             equal to the number of markets and 2 columns indicating the number of players
  #             in grou 1 and 2, respectively. Or: a vector of length equal to the number of
  #             markets with each element giving the market size.
  # CMATS     : combination matrix from function combmats.roommates() or combmats.coalitions()
  # INDEXMAT  : index matrix from function indexmat() for quick indexing to the list of
  #             combination matrices based on the number and size of groups in a market
  # 
  # Options for variable transformations:
  # add : sum over group observations and divide by group size
  # int : sum all possible two-way interactions of group members
  #       and divide by the number of those (=choose(n,2))
  # ieq : sum over all possible two-way equality assertions and
  #       divide by the number of those (=choose(n,2))
  # ive : sum over all possible two-way interactions of vectors
  #       of variables of group members and divide by number of those
  # sel : variable for individual (peer effects only!)
  # oth : variable for other in the group (peer effects only!)
  # avg : variable average for others in the group (peer effects only, not yet implemented!)
  # dst : sum over all possible two-way distances between players and divide by
  #       number of those (= choose(n,2)) where distance is defined as exp(-abs(x1-x2))
  # iln : sum all possible two-way log-interactions of group members
  #       and divide by the number of those (=choose(n,2))
  # val : valuation of player 1 (row) for player 2 (column)
  # val2: sum of valuation of players 1 and 2
  
  # ## Examples:
  #
  # ## Thai group lending paper
  # designmatrix( selection = list(add="pi", int="pi"), 
  #   outcome = list(add="pi", int="pi", ieq="wst", ive="occ"), data=data)
  # ## Simulation for coalition formation game
  # designmatrix( selection = list(add="pi", int="pi"), 
  #   outcome = list(add="pi", int="pi"), data=data)
  # ## Simulation for roommates game
  # designmatrix( selection = list(sel="pi", oth="pi", int="pi"), 
  #   outcome = list(sel="pi", oth="pi", int="pi"), data=data)
  # --------------------------------------------------------------------
  
  set.seed(seed)
  X.ind <- outcome
  W.ind <- selection
  
  ## Selected variables
  X.names <- unlist(sapply(1:length(X.ind), function(i) paste(X.ind[[i]], names(X.ind[i]), sep="@")))
  W.names <- unlist(sapply(1:length(W.ind), function(i) paste(W.ind[[i]], names(W.ind[i]), sep="@")))
  vars    <- unique(c(X.names, W.names))
  
  ## Prepare data frames
  numvills <- length(x)
  data.combs <- D <- R <- V <- P <- E <- combs <- xi <- eta <- epsilon <- 
    lapply(1:numvills, function(i) NA)
  
  cat("Processing",numvills,"markets...","\n")
  
  for(i in 1:numvills){
    
    if(i %% 10 == 0){
      cat(i,"of",numvills,"\n")
    }
    
    if(roommates){
      
      ####################
      ## ROOMMATES GAME ##
      ####################
      
      ## DEFINE AUXILIARY VARIABLES
      numI <- spec[i]
      thisdata <- x[[i]]
      thiscmat <- CMATS[[INDEXMAT[numI]]]
      ncombs <- dim(thiscmat)[1]  
      data.combs[[i]] <- data.frame(matrix(NA,ncol=length(vars),nrow=ncombs))
      names(data.combs[[i]]) <- vars
      num <- denom <- rep(1,ncombs)
      
      ## OBSERVABILITY INDICATOR, 'D'
      D[[i]] <- c(rep(1,numI), rep(0,ncombs-numI))
      
      ## OUTCOME VARIABLE, 'R'
      R[[i]] <- c(thisdata[thiscmat[1:numI,1],"R"])#, rep(NA,ncombs-numI))
      
      ## OBSERVED GROUPS
      for(j in 1:numI){
        indices <- thiscmat[j,]  
        data.combs[[i]][j,X.names] <- wrap(thisdata, indices, num, denom, j, X.names)    
      }
      
      ## UNOBSERVED GROUPS  
      for(j in (numI+1):ncombs){
        indices <- thiscmat[j,]
        data.combs[[i]][j,W.names] <- wrap(thisdata, indices, num, denom, j, W.names)    
      }      

      ## MATCH VALUATION, 'V'
      for(j in 1:ncombs){
        indices <- thiscmat[j,]  
        V[[i]][j] <- wrap(thisdata, indices, num, denom, j, "V.@val")
      }
      
      ## Replace "@" by "." in variable names
      names(data.combs[[i]]) <- gsub("@",".",names(data.combs[[i]]))
      
      if(simulation==TRUE){
                
        ## EQUILIBRIUM PAIR SELECTION
        xi[[i]]      <- rnorm(ncombs)
        eta[[i]]     <- rnorm(ncombs)
        #eta[[i]] <- data.combs[[i]][,"mot.oth"] * data.combs[[i]][,"mot.sel"]
        delta        <- 0.5
        epsilon[[i]] <- delta*eta[[i]] + xi[[i]]
        
        if(assignment=="TU"){
          
          V[[i]] <- apply(data.combs[[i]], 1, sum) + eta[[i]]
          #V[[i]] <- data.combs[[i]][,"sat.oth"] * data.combs[[i]][,"sat.sel"] + eta[[i]]
        
        } else if(assignment=="random"){
          
          V[[i]] <- rnorm(ncombs)
          
        } else(stop("assignment must be either of 'TU' or 'random'!"))
        
        ## --- Beginning of PARTITIONING LINEAR PROGRAM (PLP) ---
        ## maximizes f'x, subject to Ax <= b and x >= 0. 
        
        VV <- list()
        VV[[i]] <- matrix(NA, numI, numI)
        for(count in 1:ncombs){
          VV[[i]][thiscmat[count,1], thiscmat[count,2]] <- V[[i]][count]
        }
        VV[[i]] <- VV[[i]] + t(VV[[i]])   # mutual match valuations
        
        # valuation of all (n^2 - n)/2 possible groups.
        f <- VV[[i]][upper.tri(VV[[i]], diag=FALSE)]; f.obj <- f
        # vector of ones. every of the numI players can only be matched once! 
        b <- rep(1,numI); f.rhs <- b   
        # vector of zeros. every player must be matched at least once!
        lb <- rep(0,numI)   
        f.dir <- rep("=",numI)
        # matrix of dim nxf indicating all possible groups player i can belong to
        A <- matrix(NA,numI,length(f))  
        for(count in 1:numI){
          M <- matrix(0,numI,numI)
          M[count,] <- 1
          M[,count] <- 1
          A[count,] <- M[upper.tri(M, diag=FALSE)]
        }; f.con <- A
        
        # Integer LP solver
        #library(lpSolve)
        so <- lp(direction="max", objective.in=f.obj, const.mat=f.con, const.dir=f.dir, 
          const.rhs=f.rhs, all.bin=TRUE)
        
        # Equilibrium groups
        S <- matrix(NA, numI, numI)
        S[upper.tri(S,diag=FALSE)] <- so$solution
        G <- which(S==1,arr.ind=TRUE)
        G <- rbind(G, cbind(G[,2], G[,1]))
        equ <- which(apply(thiscmat,1,toString) %in% apply(G,1,toString))
        
        # --- End of PLP  ---
        
        data.combs[[i]] <- rbind( data.combs[[i]][equ,], data.combs[[i]][-equ,] )
        V[[i]] <- c( V[[i]][equ], V[[i]][-equ] )
        R[[i]] <- apply(data.combs[[i]][1:numI,], 1, sum) + epsilon[[i]][equ]
        
        xi[[i]]      <- xi[[i]][equ]
        eta[[i]]     <- c( eta[[i]][equ], eta[[i]][-equ])
        epsilon[[i]] <- epsilon[[i]][equ]
        
      }

    } else{ 
      
      ##########################
      ## GROUP FORMATION GAME ##
      ##########################
      
      if(i <= dim(spec)[1]){  ## 2-GROUP MARKETS
        
        ## DEFINE AUXILIARY VARIABLES
        
        # Note: numA <= numB
        numA <- spec[i,1];  rangeA <- 1:numA
        numB <- spec[i,2];  rangeB <- (numA+1):(numB+numA)
        
        thisdata <- x[[i]]
        # unobs + obs groups:
        thiscmat <- rbind( c(rangeA, rep(NA,numB-numA)), rangeB, CMATS[[INDEXMAT[numA, numB]]] )  
        ncombs   <- dim(thiscmat)[1]  
        data.combs[[i]]        <- data.frame(matrix(NA,ncol=length(vars),nrow=ncombs))  
        names(data.combs[[i]]) <- vars
        # if numA != numB, the first 1/2 contain NA:
        num   <- c(numA, numB, rep(numA,(ncombs-2)/2), rep(numB,(ncombs-2)/2))  
        denom <- c(choose(numA,2), choose(numB,2), rep(choose(numA,2),(ncombs-2)/2), rep(choose(numB,2),(ncombs-2)/2))
        
        ## OBSERVABILITY INDICATOR, 'D'
        D[[i]] <- c(rep(1,2), rep(0,ncombs-2))
        
        ## OUTCOME VARIABLE, 'R'
        #if( (abs(diff(range(thisdata[rangeA,"R"]))) > 0.1) | (abs(diff(range(thisdata[rangeB,"R"]))) > 0.1) ){
        #  stop("dependent variable must be group-level!")
        #}
        R[[i]] <- c(thisdata[rangeA,"R"][1], thisdata[rangeB,"R"][1])#, rep(NA,ncombs-2))
        
        ## OBSERVED GROUPS
        for(j in 1:2){
          indices <- thiscmat[j,1:num[j]]  
          data.combs[[i]][j,X.names] <- wrap(thisdata, indices, num, denom, j, X.names)    
        }
        
        ## UNOBSERVED GROUPS  
        for(j in 3:ncombs){
          indices <- thiscmat[j,1:num[j]]      
          data.combs[[i]][j,W.names] <- wrap(thisdata, indices, num, denom, j, W.names)    
        }
        
        ## Replace "@" by "." in variable names
        names(data.combs[[i]]) <- gsub("@",".",names(data.combs[[i]]))
        
        ## PARTNER GROUP INDEX IN SAME MARKET
        l             <- dim(thiscmat)[1]
        P[[i]]        <- c(2, 1, ((l/2)+2):l, 3:((l/2)+1))
        names(P[[i]]) <- NULL
        
        ## COMBINATION MATRICES
        combs[[i]] <- thiscmat

        
        if(simulation==TRUE){
        
          ## EQUILIBRIUM GROUP SELECTION
          xi[[i]]      <- rnorm(ncombs)
          eta[[i]]     <- rnorm(ncombs)
          delta        <- 0.5
          epsilon[[i]] <- xi[[i]] + delta*eta[[i]]
        
          V[[i]] <- apply(data.combs[[i]], 1, sum) + eta[[i]]
          
          if(assignment=="NTU"){

            ## A: NON-TRANSFERABLE UTILITY
            equ1 <- which(V[[i]]==max(V[[i]]))[1]
            equ2 <- P[[i]][equ1]
          
          } else if(assignment=="TU"){
          
            ## B: TRANSFERABLE UTILITY
            market.value <- V[[i]] + V[[i]][P[[i]]]
            equ1 <- which(market.value == max(market.value))[1]
            equ2 <- P[[i]][equ1]
            
          } else if(assignment=="random"){
            
          ## C: RANDOM GROUP ASSIGNMENT
          equ1 <- sample(1:ncombs, 1)
          equ2 <- P[[i]][equ1]
            
          } else(stop("assignment must be either of 'NTU', 'TU' or 'random'!"))

          data.combs[[i]] <- rbind( data.combs[[i]][c(equ1,equ2),], data.combs[[i]][-c(equ1,equ2),] )
          V[[i]] <- c( V[[i]][c(equ1,equ2)], V[[i]][-c(equ1,equ2)] )
          R[[i]] <- apply(data.combs[[i]][1:2,], 1, sum) + epsilon[[i]][c(equ1,equ2)]
          P[[i]] <- ifelse(P[[i]]>equ1 & P[[i]]>equ2, P[[i]], ifelse(P[[i]]<equ1 & P[[i]]<equ2, P[[i]]+2, P[[i]]+1))
          P[[i]] <- c( P[[i]][c(equ1,equ2)], P[[i]][-c(equ1,equ2)] )
          P[[i]][1:2] <- 2:1
          E[[i]] <- thiscmat[c(equ1,equ2),]

          xi[[i]]      <- xi[[i]][c(equ1,equ2)]
          eta[[i]]     <- c( eta[[i]][c(equ1,equ2)], eta[[i]][-c(equ1,equ2)] )
          epsilon[[i]] <- epsilon[[i]][c(equ1,equ2)]
          
        }
        
      } else{  ## 1-GROUP MARKETS
        
        ## DEFINE AUXILIARY VARIABLES
        thisdata <- x[[i]]
        indices  <- x[[i]]$i.id
        num      <- length(indices)
        denom    <- choose(num,2)
        
        data.combs[[i]]        <- data.frame(matrix(NA,ncol=length(vars),nrow=1))  
        names(data.combs[[i]]) <- vars
        
        ## SINGLE GROUP
        j <- 1
        data.combs[[i]][j,X.names] <- wrap(thisdata, indices, num, denom, j, X.names)
        
        ## Replace "@" by "." in variable names
        names(data.combs[[i]]) <- gsub("@",".",names(data.combs[[i]]))
        
        ## OBSERVABILITY INDICATOR, 'D', AND OUTCOME VARIABLE, 'R'
        D[[i]] <- 1
        R[[i]] <- thisdata[1,"R"]

        
        if(simulation==TRUE){
          
          xi[[i]]      <- rnorm(1)
          eta[[i]]     <- rnorm(1)
          delta        <- 0.5
          epsilon[[i]] <- delta*eta[[i]] + xi[[i]]
        
          R[[i]] <- apply(data.combs[[i]][1,], 1, sum) + epsilon[[i]]
        
        }
        
      }
    }
  }
  
  cat("done.","\n")
  
  ###################
  ## WRITE RESULTS ##
  ###################
  
  ## Replace "@" by "." in W.names and X.names
  W.names <- gsub("@",".",W.names)
  X.names <- gsub("@",".",X.names)
  
  if(roommates){
    
    W <- lapply(1:length(spec), function(i) data.combs[[i]][,W.names])
    X <- lapply(1:length(data.combs), function(i){ 
      if(i <= length(spec)){
        data.combs[[i]][1:spec[i],X.names]
      } else{
        data.combs[[i]][,X.names]
      }
    })
    return(list(D=D, R=R, W=W, X=X, V=V, epsilon=epsilon, eta=eta, xi=xi))  
    
  } else{
    
    W <- lapply(1:dim(spec)[1], function(i) data.combs[[i]][,W.names])
    X <- lapply(1:length(data.combs), function(i){ 
      if(i <= dim(spec)[1]){
        data.combs[[i]][1:2,X.names]
      } else{
        data.combs[[i]][,X.names]
      }
    })
    return(list(D=D, R=R, W=W, X=X, V=V, P=P, epsilon=epsilon, eta=eta, xi=xi, combs=combs, E=E))
  }
}
